
BlowerRamping.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002c8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  000002c8  0000035c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001d  00800062  00800062  0000035e  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000360  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000a2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000ab1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000000f2  00000000  00000000  00000ad1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000001e2  00000000  00000000  00000bc3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000000bc  00000000  00000000  00000da5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000241  00000000  00000000  00000e61  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000070  00000000  00000000  000010a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000167  00000000  00000000  00001114  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000000a2  00000000  00000000  0000127b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
   2:	2a c0       	rjmp	.+84     	; 0x58 <__bad_interrupt>
   4:	29 c0       	rjmp	.+82     	; 0x58 <__bad_interrupt>
   6:	28 c0       	rjmp	.+80     	; 0x58 <__bad_interrupt>
   8:	27 c0       	rjmp	.+78     	; 0x58 <__bad_interrupt>
   a:	26 c0       	rjmp	.+76     	; 0x58 <__bad_interrupt>
   c:	0d c1       	rjmp	.+538    	; 0x228 <__vector_6>
   e:	24 c0       	rjmp	.+72     	; 0x58 <__bad_interrupt>
  10:	23 c0       	rjmp	.+70     	; 0x58 <__bad_interrupt>
  12:	22 c0       	rjmp	.+68     	; 0x58 <__bad_interrupt>
  14:	21 c0       	rjmp	.+66     	; 0x58 <__bad_interrupt>
  16:	20 c0       	rjmp	.+64     	; 0x58 <__bad_interrupt>
  18:	1f c0       	rjmp	.+62     	; 0x58 <__bad_interrupt>
  1a:	64 c0       	rjmp	.+200    	; 0xe4 <__vector_13>
  1c:	1d c0       	rjmp	.+58     	; 0x58 <__bad_interrupt>
  1e:	1c c0       	rjmp	.+56     	; 0x58 <__bad_interrupt>
  20:	1b c0       	rjmp	.+54     	; 0x58 <__bad_interrupt>

00000022 <__ctors_end>:
  22:	11 24       	eor	r1, r1
  24:	1f be       	out	0x3f, r1	; 63
  26:	cf e5       	ldi	r28, 0x5F	; 95
  28:	d2 e0       	ldi	r29, 0x02	; 2
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_copy_data>:
  2e:	10 e0       	ldi	r17, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	e8 ec       	ldi	r30, 0xC8	; 200
  36:	f2 e0       	ldi	r31, 0x02	; 2
  38:	02 c0       	rjmp	.+4      	; 0x3e <__SP_H__>
  3a:	05 90       	lpm	r0, Z+
  3c:	0d 92       	st	X+, r0
  3e:	a2 36       	cpi	r26, 0x62	; 98
  40:	b1 07       	cpc	r27, r17
  42:	d9 f7       	brne	.-10     	; 0x3a <__CCP__+0x6>

00000044 <__do_clear_bss>:
  44:	10 e0       	ldi	r17, 0x00	; 0
  46:	a2 e6       	ldi	r26, 0x62	; 98
  48:	b0 e0       	ldi	r27, 0x00	; 0
  4a:	01 c0       	rjmp	.+2      	; 0x4e <.do_clear_bss_start>

0000004c <.do_clear_bss_loop>:
  4c:	1d 92       	st	X+, r1

0000004e <.do_clear_bss_start>:
  4e:	af 37       	cpi	r26, 0x7F	; 127
  50:	b1 07       	cpc	r27, r17
  52:	e1 f7       	brne	.-8      	; 0x4c <.do_clear_bss_loop>
  54:	44 d0       	rcall	.+136    	; 0xde <main>
  56:	36 c1       	rjmp	.+620    	; 0x2c4 <_exit>

00000058 <__bad_interrupt>:
  58:	d3 cf       	rjmp	.-90     	; 0x0 <__vectors>

0000005a <InitHardware>:

void InitHardware(void)
{
    // ==== Portpins ====
    // CPU LED is output
    DDR_LED_CPU = DDR_LED_CPU | _BV(BIT_LED_CPU);
  5a:	ea e3       	ldi	r30, 0x3A	; 58
  5c:	f0 e0       	ldi	r31, 0x00	; 0
  5e:	80 81       	ld	r24, Z
  60:	80 61       	ori	r24, 0x10	; 16
  62:	80 83       	st	Z, r24

    // Status LED is output
    DDR_LED_STAT = DDR_LED_STAT | _BV(BIT_LED_STAT);
  64:	80 81       	ld	r24, Z
  66:	80 62       	ori	r24, 0x20	; 32
  68:	80 83       	st	Z, r24
    PORT_LED_STAT = PORT_LED_STAT | _BV(BIT_LED_STAT);  // LED off (active low)
  6a:	ab e3       	ldi	r26, 0x3B	; 59
  6c:	b0 e0       	ldi	r27, 0x00	; 0
  6e:	8c 91       	ld	r24, X
  70:	80 62       	ori	r24, 0x20	; 32
  72:	8c 93       	st	X, r24

    // external status is output
    DDR_LED_EXSTAT = DDR_LED_EXSTAT | _BV(BIT_LED_EXSTAT);
  74:	80 81       	ld	r24, Z
  76:	88 60       	ori	r24, 0x08	; 8
  78:	80 83       	st	Z, r24
    PORT_LED_EXSTAT = PORT_LED_EXSTAT & ~_BV(BIT_LED_EXSTAT);  // ext. stat off
  7a:	8c 91       	ld	r24, X
  7c:	87 7f       	andi	r24, 0xF7	; 247
  7e:	8c 93       	st	X, r24

    // PWM pin is output
    DDR_PWM = DDR_PWM | _BV(BIT_PWM);
  80:	80 81       	ld	r24, Z
  82:	80 68       	ori	r24, 0x80	; 128
  84:	80 83       	st	Z, r24
    PORT_PWM = PORT_PWM & ~_BV(BIT_PWM);    // turn off DAC
  86:	8c 91       	ld	r24, X
  88:	8f 77       	andi	r24, 0x7F	; 127
  8a:	8c 93       	st	X, r24
    
    // ==== ADC Stuff below ====
    // prepare ADC (disconnect digital port)
    DIDR0 = DIDR0 | _BV(ADC0D);
  8c:	e1 e2       	ldi	r30, 0x21	; 33
  8e:	f0 e0       	ldi	r31, 0x00	; 0
  90:	80 81       	ld	r24, Z
  92:	81 60       	ori	r24, 0x01	; 1
  94:	80 83       	st	Z, r24

    // MUX & Ref
    ADMUX = 0x00;   // Channel0, VCC as reference
  96:	17 b8       	out	0x07, r1	; 7

    // Auto Trigger Source = free running, left adjust 10bit 
    ADCSRB = _BV(ADLAR);
  98:	80 e1       	ldi	r24, 0x10	; 16
  9a:	83 b9       	out	0x03, r24	; 3

    // Prescaler 1:128, free running mode, enable ADC, 62,5KHz Sample Rate
    ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADATE) | _BV(ADIE) | _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
  9c:	8f ee       	ldi	r24, 0xEF	; 239
  9e:	86 b9       	out	0x06, r24	; 6

    // ==== PWM Output on OC0B (PA7) ====
    TCCR0A = (1<<COM0B1) | (1<<WGM01) | (1<<WGM00); // 0xA3 Mode 3 Fast-PWM TOP=0xFF
  a0:	83 e2       	ldi	r24, 0x23	; 35
  a2:	80 bf       	out	0x30, r24	; 48
    TCCR0B = (1<<CS00);  // no prescaler -> 31250 Hz PWM frequency
  a4:	81 e0       	ldi	r24, 0x01	; 1
  a6:	83 bf       	out	0x33, r24	; 51

    OCR0B = 0x00;
  a8:	1c be       	out	0x3c, r1	; 60

};
  aa:	08 95       	ret

000000ac <InitTimer1CompareAInt>:

void InitTimer1CompareAInt(void)
{
    TIFR0 |= (1<<OCF1A);                // Interrupt Request loeschen
  ac:	e8 e5       	ldi	r30, 0x58	; 88
  ae:	f0 e0       	ldi	r31, 0x00	; 0
  b0:	80 81       	ld	r24, Z
  b2:	82 60       	ori	r24, 0x02	; 2
  b4:	80 83       	st	Z, r24
    TIMSK1 |= (1<<OCIE1A);              // Enable Output Compare A Interrupt
  b6:	ec e2       	ldi	r30, 0x2C	; 44
  b8:	f0 e0       	ldi	r31, 0x00	; 0
  ba:	80 81       	ld	r24, Z
  bc:	82 60       	ori	r24, 0x02	; 2
  be:	80 83       	st	Z, r24

    OCR1AH = 124 >> 8;                // CompareTime (16bit) 
  c0:	1b bc       	out	0x2b, r1	; 43
    OCR1AL = 124 & 0xFF;              // CompareTime (16bit) 
  c2:	8c e7       	ldi	r24, 0x7C	; 124
  c4:	8a bd       	out	0x2a, r24	; 42

    TCNT1 = 0;
  c6:	1d bc       	out	0x2d, r1	; 45
  c8:	1c bc       	out	0x2c, r1	; 44
    TCCR1B   |= 1 << WGM12;             // CTC Mode 4 (16bit CTC)
  ca:	ee e4       	ldi	r30, 0x4E	; 78
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	80 81       	ld	r24, Z
  d0:	88 60       	ori	r24, 0x08	; 8
  d2:	80 83       	st	Z, r24

    TCCR1B   |= (1<<CS01) | (1<<CS00);  // 64 prescaler, Timer0 Start
  d4:	80 81       	ld	r24, Z
  d6:	83 60       	ori	r24, 0x03	; 3
  d8:	80 83       	st	Z, r24
    sei();
  da:	78 94       	sei
}
  dc:	08 95       	ret

000000de <main>:



int main()
{
    InitHardware();
  de:	bd df       	rcall	.-134    	; 0x5a <InitHardware>
    InitTimer1CompareAInt();
  e0:	e5 df       	rcall	.-54     	; 0xac <InitTimer1CompareAInt>
  e2:	ff cf       	rjmp	.-2      	; 0xe2 <main+0x4>

000000e4 <__vector_13>:
    DebounceKeys();
}

// ADC interrupt
ISR(ADC_vect)
{
  e4:	1f 92       	push	r1
  e6:	0f 92       	push	r0
  e8:	0f b6       	in	r0, 0x3f	; 63
  ea:	0f 92       	push	r0
  ec:	11 24       	eor	r1, r1
  ee:	2f 93       	push	r18
  f0:	3f 93       	push	r19
  f2:	4f 93       	push	r20
  f4:	5f 93       	push	r21
  f6:	6f 93       	push	r22
  f8:	7f 93       	push	r23
  fa:	8f 93       	push	r24
  fc:	9f 93       	push	r25
  fe:	af 93       	push	r26
 100:	bf 93       	push	r27
 102:	ef 93       	push	r30
 104:	ff 93       	push	r31
 106:	df 93       	push	r29
 108:	cf 93       	push	r28
 10a:	0f 92       	push	r0
 10c:	cd b7       	in	r28, 0x3d	; 61
 10e:	de b7       	in	r29, 0x3e	; 62
    unsigned int uiLoop;
    unsigned int uiSumm;

    // read sample from ADH
    // we only have 8bit PWM, so 8bit ADC is sufficient
    volatile unsigned char ucCurrentSample = ADCH;
 110:	85 b1       	in	r24, 0x05	; 5
 112:	89 83       	std	Y+1, r24	; 0x01
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	90 e0       	ldi	r25, 0x00	; 0
    // value in Index 0 gets lost, MAX_ADC_HIST-1 gets free for
    // current sample

    for(uiLoop = 1; uiLoop < MAX_ADC_HIST; uiLoop++)
    {
        aRunningAverageBuffer[uiLoop-1] = aRunningAverageBuffer[uiLoop];
 118:	22 e6       	ldi	r18, 0x62	; 98
 11a:	30 e0       	ldi	r19, 0x00	; 0
    unsigned int uiLoop;
    unsigned int uiSumm;

    // read sample from ADH
    // we only have 8bit PWM, so 8bit ADC is sufficient
    volatile unsigned char ucCurrentSample = ADCH;
 11c:	fc 01       	movw	r30, r24
 11e:	31 97       	sbiw	r30, 0x01	; 1
    // value in Index 0 gets lost, MAX_ADC_HIST-1 gets free for
    // current sample

    for(uiLoop = 1; uiLoop < MAX_ADC_HIST; uiLoop++)
    {
        aRunningAverageBuffer[uiLoop-1] = aRunningAverageBuffer[uiLoop];
 120:	d9 01       	movw	r26, r18
 122:	a8 0f       	add	r26, r24
 124:	b9 1f       	adc	r27, r25
 126:	4c 91       	ld	r20, X
 128:	e2 0f       	add	r30, r18
 12a:	f3 1f       	adc	r31, r19
 12c:	40 83       	st	Z, r20

    // move all values one index to the front
    // value in Index 0 gets lost, MAX_ADC_HIST-1 gets free for
    // current sample

    for(uiLoop = 1; uiLoop < MAX_ADC_HIST; uiLoop++)
 12e:	01 96       	adiw	r24, 0x01	; 1
 130:	84 31       	cpi	r24, 0x14	; 20
 132:	91 05       	cpc	r25, r1
 134:	99 f7       	brne	.-26     	; 0x11c <__vector_13+0x38>
    {
        aRunningAverageBuffer[uiLoop-1] = aRunningAverageBuffer[uiLoop];
    };

    // current sample on last index
    aRunningAverageBuffer[(MAX_ADC_HIST-1)] = ucCurrentSample;
 136:	89 81       	ldd	r24, Y+1	; 0x01
 138:	80 93 75 00 	sts	0x0075, r24
 13c:	80 e0       	ldi	r24, 0x00	; 0
 13e:	90 e0       	ldi	r25, 0x00	; 0
 140:	20 e0       	ldi	r18, 0x00	; 0
 142:	30 e0       	ldi	r19, 0x00	; 0
    uiSumm = 0;
    
    // add up all data
    for(uiLoop=0;uiLoop<MAX_ADC_HIST; uiLoop++)
    {
        uiSumm = uiSumm + aRunningAverageBuffer[uiLoop];
 144:	62 e6       	ldi	r22, 0x62	; 98
 146:	70 e0       	ldi	r23, 0x00	; 0
 148:	fb 01       	movw	r30, r22
 14a:	e2 0f       	add	r30, r18
 14c:	f3 1f       	adc	r31, r19
 14e:	40 81       	ld	r20, Z
 150:	84 0f       	add	r24, r20
 152:	91 1d       	adc	r25, r1
    aRunningAverageBuffer[(MAX_ADC_HIST-1)] = ucCurrentSample;

    uiSumm = 0;
    
    // add up all data
    for(uiLoop=0;uiLoop<MAX_ADC_HIST; uiLoop++)
 154:	2f 5f       	subi	r18, 0xFF	; 255
 156:	3f 4f       	sbci	r19, 0xFF	; 255
 158:	24 31       	cpi	r18, 0x14	; 20
 15a:	31 05       	cpc	r19, r1
 15c:	a9 f7       	brne	.-22     	; 0x148 <__vector_13+0x64>
    {
        uiSumm = uiSumm + aRunningAverageBuffer[uiLoop];
    };

    // update average
    ucADCMeanValue = (unsigned char)(uiSumm / MAX_ADC_HIST);
 15e:	64 e1       	ldi	r22, 0x14	; 20
 160:	70 e0       	ldi	r23, 0x00	; 0
 162:	9c d0       	rcall	.+312    	; 0x29c <__udivmodhi4>
 164:	60 93 79 00 	sts	0x0079, r22
    OCR0B = ucADCMeanValue;
 168:	80 91 79 00 	lds	r24, 0x0079
 16c:	8c bf       	out	0x3c, r24	; 60
        
}
 16e:	0f 90       	pop	r0
 170:	cf 91       	pop	r28
 172:	df 91       	pop	r29
 174:	ff 91       	pop	r31
 176:	ef 91       	pop	r30
 178:	bf 91       	pop	r27
 17a:	af 91       	pop	r26
 17c:	9f 91       	pop	r25
 17e:	8f 91       	pop	r24
 180:	7f 91       	pop	r23
 182:	6f 91       	pop	r22
 184:	5f 91       	pop	r21
 186:	4f 91       	pop	r20
 188:	3f 91       	pop	r19
 18a:	2f 91       	pop	r18
 18c:	0f 90       	pop	r0
 18e:	0f be       	out	0x3f, r0	; 63
 190:	0f 90       	pop	r0
 192:	1f 90       	pop	r1
 194:	18 95       	reti

00000196 <DebounceKeys>:


// Keyboard debouncing 
void DebounceKeys(void)
{
 196:	df 93       	push	r29
 198:	cf 93       	push	r28
 19a:	0f 92       	push	r0
 19c:	cd b7       	in	r28, 0x3d	; 61
 19e:	de b7       	in	r29, 0x3e	; 62
	unsigned int uiLoop;
    volatile unsigned char  ucTempState;		// needed for array checking

	ucOldDebouncedState = ucDebouncedState;		// save old value to check if something has changed
 1a0:	80 91 77 00 	lds	r24, 0x0077
 1a4:	80 93 76 00 	sts	0x0076, r24

    // read hardware here
	aKeyState[ucDebounceIndex] = (~(PINA & _BV(BIT_EN_INP))) & _BV(BIT_EN_INP);// we only process a single key (low active), mask rest
 1a8:	90 91 78 00 	lds	r25, 0x0078
 1ac:	89 b3       	in	r24, 0x19	; 25
 1ae:	82 70       	andi	r24, 0x02	; 2
 1b0:	80 95       	com	r24
 1b2:	82 70       	andi	r24, 0x02	; 2
 1b4:	ea e7       	ldi	r30, 0x7A	; 122
 1b6:	f0 e0       	ldi	r31, 0x00	; 0
 1b8:	e9 0f       	add	r30, r25
 1ba:	f1 1d       	adc	r31, r1
 1bc:	80 83       	st	Z, r24
	++ucDebounceIndex;
 1be:	80 91 78 00 	lds	r24, 0x0078
 1c2:	8f 5f       	subi	r24, 0xFF	; 255
 1c4:	80 93 78 00 	sts	0x0078, r24

	ucTempState = 0xFF;
 1c8:	8f ef       	ldi	r24, 0xFF	; 255
 1ca:	89 83       	std	Y+1, r24	; 0x01
 1cc:	80 e0       	ldi	r24, 0x00	; 0
 1ce:	90 e0       	ldi	r25, 0x00	; 0

    // iterate through the last states and see if each
    // bit of each state is 1
	for(uiLoop=0; uiLoop < (MAX_KEY_CHECKS-1); uiLoop++)
		ucTempState = ucTempState & aKeyState[uiLoop];
 1d0:	4a e7       	ldi	r20, 0x7A	; 122
 1d2:	50 e0       	ldi	r21, 0x00	; 0
 1d4:	fa 01       	movw	r30, r20
 1d6:	e8 0f       	add	r30, r24
 1d8:	f9 1f       	adc	r31, r25
 1da:	30 81       	ld	r19, Z
 1dc:	29 81       	ldd	r18, Y+1	; 0x01
 1de:	23 23       	and	r18, r19
 1e0:	29 83       	std	Y+1, r18	; 0x01

	ucTempState = 0xFF;

    // iterate through the last states and see if each
    // bit of each state is 1
	for(uiLoop=0; uiLoop < (MAX_KEY_CHECKS-1); uiLoop++)
 1e2:	01 96       	adiw	r24, 0x01	; 1
 1e4:	84 30       	cpi	r24, 0x04	; 4
 1e6:	91 05       	cpc	r25, r1
 1e8:	a9 f7       	brne	.-22     	; 0x1d4 <DebounceKeys+0x3e>
		ucTempState = ucTempState & aKeyState[uiLoop];

	ucDebouncedState = ucTempState;
 1ea:	89 81       	ldd	r24, Y+1	; 0x01
 1ec:	80 93 77 00 	sts	0x0077, r24

    // wrap around pointer 
	if(ucDebounceIndex >= MAX_KEY_CHECKS)
 1f0:	80 91 78 00 	lds	r24, 0x0078
 1f4:	85 30       	cpi	r24, 0x05	; 5
 1f6:	10 f0       	brcs	.+4      	; 0x1fc <DebounceKeys+0x66>
		ucDebounceIndex=0;
 1f8:	10 92 78 00 	sts	0x0078, r1

    // check if external enable input changed
    if((ucOldDebouncedState & _BV(BIT_EN_INP)) != (ucDebouncedState & _BV(BIT_EN_INP)))
 1fc:	80 91 76 00 	lds	r24, 0x0076
 200:	20 91 77 00 	lds	r18, 0x0077
 204:	30 e0       	ldi	r19, 0x00	; 0
 206:	90 e0       	ldi	r25, 0x00	; 0
 208:	82 27       	eor	r24, r18
 20a:	93 27       	eor	r25, r19
 20c:	81 ff       	sbrs	r24, 1
 20e:	08 c0       	rjmp	.+16     	; 0x220 <DebounceKeys+0x8a>
    {
        // check if it was a low to high transition
        if(ucDebouncedState & _BV(BIT_EN_INP))
 210:	80 91 77 00 	lds	r24, 0x0077
 214:	81 ff       	sbrs	r24, 1
 216:	04 c0       	rjmp	.+8      	; 0x220 <DebounceKeys+0x8a>
        {
            PORT_LED_EXSTAT = PIN_LED_EXSTAT ^ _BV(BIT_LED_EXSTAT);  // ext. stat off            
 218:	99 b3       	in	r25, 0x19	; 25
 21a:	88 e0       	ldi	r24, 0x08	; 8
 21c:	89 27       	eor	r24, r25
 21e:	8b bb       	out	0x1b, r24	; 27
        };
    };
}
 220:	0f 90       	pop	r0
 222:	cf 91       	pop	r28
 224:	df 91       	pop	r29
 226:	08 95       	ret

00000228 <__vector_6>:
}

 
// time management handler, called every 1ms via CTC mode interrupt
ISR(TIM1_COMPA_vect)
{
 228:	1f 92       	push	r1
 22a:	0f 92       	push	r0
 22c:	0f b6       	in	r0, 0x3f	; 63
 22e:	0f 92       	push	r0
 230:	11 24       	eor	r1, r1
 232:	2f 93       	push	r18
 234:	3f 93       	push	r19
 236:	4f 93       	push	r20
 238:	5f 93       	push	r21
 23a:	6f 93       	push	r22
 23c:	7f 93       	push	r23
 23e:	8f 93       	push	r24
 240:	9f 93       	push	r25
 242:	af 93       	push	r26
 244:	bf 93       	push	r27
 246:	ef 93       	push	r30
 248:	ff 93       	push	r31
    static unsigned int uiBlinkDelay = 500;

    if(!(uiBlinkDelay--))
 24a:	80 91 60 00 	lds	r24, 0x0060
 24e:	90 91 61 00 	lds	r25, 0x0061
 252:	9c 01       	movw	r18, r24
 254:	21 50       	subi	r18, 0x01	; 1
 256:	30 40       	sbci	r19, 0x00	; 0
 258:	30 93 61 00 	sts	0x0061, r19
 25c:	20 93 60 00 	sts	0x0060, r18
 260:	00 97       	sbiw	r24, 0x00	; 0
 262:	51 f4       	brne	.+20     	; 0x278 <__stack+0x19>
    {
        PORT_LED_CPU = PIN_LED_CPU ^ _BV(BIT_LED_CPU);
 264:	99 b3       	in	r25, 0x19	; 25
 266:	80 e1       	ldi	r24, 0x10	; 16
 268:	89 27       	eor	r24, r25
 26a:	8b bb       	out	0x1b, r24	; 27
        uiBlinkDelay = 500;
 26c:	84 ef       	ldi	r24, 0xF4	; 244
 26e:	91 e0       	ldi	r25, 0x01	; 1
 270:	90 93 61 00 	sts	0x0061, r25
 274:	80 93 60 00 	sts	0x0060, r24
    };
    DebounceKeys();
 278:	8e df       	rcall	.-228    	; 0x196 <DebounceKeys>
}
 27a:	ff 91       	pop	r31
 27c:	ef 91       	pop	r30
 27e:	bf 91       	pop	r27
 280:	af 91       	pop	r26
 282:	9f 91       	pop	r25
 284:	8f 91       	pop	r24
 286:	7f 91       	pop	r23
 288:	6f 91       	pop	r22
 28a:	5f 91       	pop	r21
 28c:	4f 91       	pop	r20
 28e:	3f 91       	pop	r19
 290:	2f 91       	pop	r18
 292:	0f 90       	pop	r0
 294:	0f be       	out	0x3f, r0	; 63
 296:	0f 90       	pop	r0
 298:	1f 90       	pop	r1
 29a:	18 95       	reti

0000029c <__udivmodhi4>:
 29c:	aa 1b       	sub	r26, r26
 29e:	bb 1b       	sub	r27, r27
 2a0:	51 e1       	ldi	r21, 0x11	; 17
 2a2:	07 c0       	rjmp	.+14     	; 0x2b2 <__udivmodhi4_ep>

000002a4 <__udivmodhi4_loop>:
 2a4:	aa 1f       	adc	r26, r26
 2a6:	bb 1f       	adc	r27, r27
 2a8:	a6 17       	cp	r26, r22
 2aa:	b7 07       	cpc	r27, r23
 2ac:	10 f0       	brcs	.+4      	; 0x2b2 <__udivmodhi4_ep>
 2ae:	a6 1b       	sub	r26, r22
 2b0:	b7 0b       	sbc	r27, r23

000002b2 <__udivmodhi4_ep>:
 2b2:	88 1f       	adc	r24, r24
 2b4:	99 1f       	adc	r25, r25
 2b6:	5a 95       	dec	r21
 2b8:	a9 f7       	brne	.-22     	; 0x2a4 <__udivmodhi4_loop>
 2ba:	80 95       	com	r24
 2bc:	90 95       	com	r25
 2be:	bc 01       	movw	r22, r24
 2c0:	cd 01       	movw	r24, r26
 2c2:	08 95       	ret

000002c4 <_exit>:
 2c4:	f8 94       	cli

000002c6 <__stop_program>:
 2c6:	ff cf       	rjmp	.-2      	; 0x2c6 <__stop_program>
