
BlowerRamping.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  00800060  000004b6  0000054a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002b  00800064  00800064  0000054e  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000550  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000ca1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000015d  00000000  00000000  00000cc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000002ea  00000000  00000000  00000e1e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000107  00000000  00000000  00001108  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000003e5  00000000  00000000  0000120f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000070  00000000  00000000  000015f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000270  00000000  00000000  00001664  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000000a2  00000000  00000000  000018d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
   2:	2a c0       	rjmp	.+84     	; 0x58 <__bad_interrupt>
   4:	29 c0       	rjmp	.+82     	; 0x58 <__bad_interrupt>
   6:	28 c0       	rjmp	.+80     	; 0x58 <__bad_interrupt>
   8:	27 c0       	rjmp	.+78     	; 0x58 <__bad_interrupt>
   a:	26 c0       	rjmp	.+76     	; 0x58 <__bad_interrupt>
   c:	0e c1       	rjmp	.+540    	; 0x22a <__vector_6>
   e:	24 c0       	rjmp	.+72     	; 0x58 <__bad_interrupt>
  10:	23 c0       	rjmp	.+70     	; 0x58 <__bad_interrupt>
  12:	22 c0       	rjmp	.+68     	; 0x58 <__bad_interrupt>
  14:	21 c0       	rjmp	.+66     	; 0x58 <__bad_interrupt>
  16:	20 c0       	rjmp	.+64     	; 0x58 <__bad_interrupt>
  18:	1f c0       	rjmp	.+62     	; 0x58 <__bad_interrupt>
  1a:	6b c0       	rjmp	.+214    	; 0xf2 <__vector_13>
  1c:	1d c0       	rjmp	.+58     	; 0x58 <__bad_interrupt>
  1e:	1c c0       	rjmp	.+56     	; 0x58 <__bad_interrupt>
  20:	1b c0       	rjmp	.+54     	; 0x58 <__bad_interrupt>

00000022 <__ctors_end>:
  22:	11 24       	eor	r1, r1
  24:	1f be       	out	0x3f, r1	; 63
  26:	cf e5       	ldi	r28, 0x5F	; 95
  28:	d2 e0       	ldi	r29, 0x02	; 2
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_copy_data>:
  2e:	10 e0       	ldi	r17, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	e6 eb       	ldi	r30, 0xB6	; 182
  36:	f4 e0       	ldi	r31, 0x04	; 4
  38:	02 c0       	rjmp	.+4      	; 0x3e <__SP_H__>
  3a:	05 90       	lpm	r0, Z+
  3c:	0d 92       	st	X+, r0
  3e:	a4 36       	cpi	r26, 0x64	; 100
  40:	b1 07       	cpc	r27, r17
  42:	d9 f7       	brne	.-10     	; 0x3a <__CCP__+0x6>

00000044 <__do_clear_bss>:
  44:	10 e0       	ldi	r17, 0x00	; 0
  46:	a4 e6       	ldi	r26, 0x64	; 100
  48:	b0 e0       	ldi	r27, 0x00	; 0
  4a:	01 c0       	rjmp	.+2      	; 0x4e <.do_clear_bss_start>

0000004c <.do_clear_bss_loop>:
  4c:	1d 92       	st	X+, r1

0000004e <.do_clear_bss_start>:
  4e:	af 38       	cpi	r26, 0x8F	; 143
  50:	b1 07       	cpc	r27, r17
  52:	e1 f7       	brne	.-8      	; 0x4c <.do_clear_bss_loop>
  54:	47 d0       	rcall	.+142    	; 0xe4 <main>
  56:	2d c2       	rjmp	.+1114   	; 0x4b2 <_exit>

00000058 <__bad_interrupt>:
  58:	d3 cf       	rjmp	.-90     	; 0x0 <__vectors>

0000005a <InitHardware>:

void InitHardware(void)
{
    // ==== Portpins ====
    // CPU LED is output
    DDR_LED_CPU = DDR_LED_CPU | _BV(BIT_LED_CPU);
  5a:	ea e3       	ldi	r30, 0x3A	; 58
  5c:	f0 e0       	ldi	r31, 0x00	; 0
  5e:	80 81       	ld	r24, Z
  60:	80 61       	ori	r24, 0x10	; 16
  62:	80 83       	st	Z, r24

    // Status LED is output
    DDR_LED_STAT = DDR_LED_STAT | _BV(BIT_LED_STAT);
  64:	80 81       	ld	r24, Z
  66:	80 62       	ori	r24, 0x20	; 32
  68:	80 83       	st	Z, r24
    PORT_LED_STAT = PORT_LED_STAT | _BV(BIT_LED_STAT);  // LED off (active low)
  6a:	ab e3       	ldi	r26, 0x3B	; 59
  6c:	b0 e0       	ldi	r27, 0x00	; 0
  6e:	8c 91       	ld	r24, X
  70:	80 62       	ori	r24, 0x20	; 32
  72:	8c 93       	st	X, r24

    // external status is output
    DDR_LED_EXSTAT = DDR_LED_EXSTAT | _BV(BIT_LED_EXSTAT);
  74:	80 81       	ld	r24, Z
  76:	88 60       	ori	r24, 0x08	; 8
  78:	80 83       	st	Z, r24
    PORT_LED_EXSTAT = PORT_LED_EXSTAT & ~_BV(BIT_LED_EXSTAT);  // ext. stat off
  7a:	8c 91       	ld	r24, X
  7c:	87 7f       	andi	r24, 0xF7	; 247
  7e:	8c 93       	st	X, r24

    // PWM pin is output
    DDR_PWM = DDR_PWM | _BV(BIT_PWM);
  80:	80 81       	ld	r24, Z
  82:	80 68       	ori	r24, 0x80	; 128
  84:	80 83       	st	Z, r24
    PORT_PWM = PORT_PWM & ~_BV(BIT_PWM);    // turn off DAC
  86:	8c 91       	ld	r24, X
  88:	8f 77       	andi	r24, 0x7F	; 127
  8a:	8c 93       	st	X, r24

    // ERROR Pins on PB are input;
    DDRB = 0x00;
  8c:	17 ba       	out	0x17, r1	; 23

    // enable Pullups on PB0 to PB2
    PORTB = 0x07;
  8e:	87 e0       	ldi	r24, 0x07	; 7
  90:	88 bb       	out	0x18, r24	; 24
    
    // ==== ADC Stuff below ====
    // prepare ADC (disconnect digital port)
    DIDR0 = DIDR0 | _BV(ADC0D);
  92:	e1 e2       	ldi	r30, 0x21	; 33
  94:	f0 e0       	ldi	r31, 0x00	; 0
  96:	80 81       	ld	r24, Z
  98:	81 60       	ori	r24, 0x01	; 1
  9a:	80 83       	st	Z, r24

    // MUX & Ref
    ADMUX = 0x00;   // Channel0, VCC as reference
  9c:	17 b8       	out	0x07, r1	; 7

    // Auto Trigger Source = free running, left adjust 10bit 
    ADCSRB = _BV(ADLAR);
  9e:	80 e1       	ldi	r24, 0x10	; 16
  a0:	83 b9       	out	0x03, r24	; 3

    // Prescaler 1:128, free running mode, enable ADC, 62,5KHz Sample Rate
    ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADATE) | _BV(ADIE) | _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
  a2:	8f ee       	ldi	r24, 0xEF	; 239
  a4:	86 b9       	out	0x06, r24	; 6

    // ==== PWM Output on OC0B (PA7) ====
    TCCR0A = (1<<COM0B1) | (1<<WGM01) | (1<<WGM00); // 0xA3 Mode 3 Fast-PWM TOP=0xFF
  a6:	83 e2       	ldi	r24, 0x23	; 35
  a8:	80 bf       	out	0x30, r24	; 48
    TCCR0B = (1<<CS00);  // no prescaler -> 31250 Hz PWM frequency
  aa:	81 e0       	ldi	r24, 0x01	; 1
  ac:	83 bf       	out	0x33, r24	; 51

    OCR0B = 0x00;
  ae:	1c be       	out	0x3c, r1	; 60

};
  b0:	08 95       	ret

000000b2 <InitTimer1CompareAInt>:

void InitTimer1CompareAInt(void)
{
    TIFR0 |= (1<<OCF1A);                // Interrupt Request loeschen
  b2:	e8 e5       	ldi	r30, 0x58	; 88
  b4:	f0 e0       	ldi	r31, 0x00	; 0
  b6:	80 81       	ld	r24, Z
  b8:	82 60       	ori	r24, 0x02	; 2
  ba:	80 83       	st	Z, r24
    TIMSK1 |= (1<<OCIE1A);              // Enable Output Compare A Interrupt
  bc:	ec e2       	ldi	r30, 0x2C	; 44
  be:	f0 e0       	ldi	r31, 0x00	; 0
  c0:	80 81       	ld	r24, Z
  c2:	82 60       	ori	r24, 0x02	; 2
  c4:	80 83       	st	Z, r24

    OCR1AH = 124 >> 8;                // CompareTime (16bit) 
  c6:	1b bc       	out	0x2b, r1	; 43
    OCR1AL = 124 & 0xFF;              // CompareTime (16bit) 
  c8:	8c e7       	ldi	r24, 0x7C	; 124
  ca:	8a bd       	out	0x2a, r24	; 42

    TCNT1 = 0;
  cc:	1d bc       	out	0x2d, r1	; 45
  ce:	1c bc       	out	0x2c, r1	; 44
    TCCR1B   |= 1 << WGM12;             // CTC Mode 4 (16bit CTC)
  d0:	ee e4       	ldi	r30, 0x4E	; 78
  d2:	f0 e0       	ldi	r31, 0x00	; 0
  d4:	80 81       	ld	r24, Z
  d6:	88 60       	ori	r24, 0x08	; 8
  d8:	80 83       	st	Z, r24

    TCCR1B   |= (1<<CS01) | (1<<CS00);  // 64 prescaler, Timer0 Start
  da:	80 81       	ld	r24, Z
  dc:	83 60       	ori	r24, 0x03	; 3
  de:	80 83       	st	Z, r24
    sei();
  e0:	78 94       	sei
}
  e2:	08 95       	ret

000000e4 <main>:

// main loop

int main()
{
    InitHardware();
  e4:	ba df       	rcall	.-140    	; 0x5a <InitHardware>
    InitTimer1CompareAInt();
  e6:	e5 df       	rcall	.-54     	; 0xb2 <InitTimer1CompareAInt>

    eRampingState = eRampedDown;
  e8:	10 92 7b 00 	sts	0x007B, r1
    eMorseState = eMorsePause;
  ec:	10 92 7d 00 	sts	0x007D, r1
  f0:	ff cf       	rjmp	.-2      	; 0xf0 <main+0xc>

000000f2 <__vector_13>:
    DebounceKeys();
}

// ADC interrupt
ISR(ADC_vect)
{
  f2:	1f 92       	push	r1
  f4:	0f 92       	push	r0
  f6:	0f b6       	in	r0, 0x3f	; 63
  f8:	0f 92       	push	r0
  fa:	11 24       	eor	r1, r1
  fc:	2f 93       	push	r18
  fe:	3f 93       	push	r19
 100:	4f 93       	push	r20
 102:	5f 93       	push	r21
 104:	6f 93       	push	r22
 106:	7f 93       	push	r23
 108:	8f 93       	push	r24
 10a:	9f 93       	push	r25
 10c:	af 93       	push	r26
 10e:	bf 93       	push	r27
 110:	ef 93       	push	r30
 112:	ff 93       	push	r31
 114:	df 93       	push	r29
 116:	cf 93       	push	r28
 118:	0f 92       	push	r0
 11a:	cd b7       	in	r28, 0x3d	; 61
 11c:	de b7       	in	r29, 0x3e	; 62
    unsigned int uiLoop;
    unsigned int uiSumm;

    // read sample from ADH
    // we only have 8bit PWM, so 8bit ADC is sufficient
    volatile unsigned char ucCurrentSample = ADCH;
 11e:	85 b1       	in	r24, 0x05	; 5
 120:	89 83       	std	Y+1, r24	; 0x01
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	90 e0       	ldi	r25, 0x00	; 0
    // value in Index 0 gets lost, MAX_ADC_HIST-1 gets free for
    // current sample

    for(uiLoop = 1; uiLoop < MAX_ADC_HIST; uiLoop++)
    {
        aRunningAverageBuffer[uiLoop-1] = aRunningAverageBuffer[uiLoop];
 126:	25 e6       	ldi	r18, 0x65	; 101
 128:	30 e0       	ldi	r19, 0x00	; 0
    unsigned int uiLoop;
    unsigned int uiSumm;

    // read sample from ADH
    // we only have 8bit PWM, so 8bit ADC is sufficient
    volatile unsigned char ucCurrentSample = ADCH;
 12a:	fc 01       	movw	r30, r24
 12c:	31 97       	sbiw	r30, 0x01	; 1
    // value in Index 0 gets lost, MAX_ADC_HIST-1 gets free for
    // current sample

    for(uiLoop = 1; uiLoop < MAX_ADC_HIST; uiLoop++)
    {
        aRunningAverageBuffer[uiLoop-1] = aRunningAverageBuffer[uiLoop];
 12e:	d9 01       	movw	r26, r18
 130:	a8 0f       	add	r26, r24
 132:	b9 1f       	adc	r27, r25
 134:	4c 91       	ld	r20, X
 136:	e2 0f       	add	r30, r18
 138:	f3 1f       	adc	r31, r19
 13a:	40 83       	st	Z, r20

    // move all values one index to the front
    // value in Index 0 gets lost, MAX_ADC_HIST-1 gets free for
    // current sample

    for(uiLoop = 1; uiLoop < MAX_ADC_HIST; uiLoop++)
 13c:	01 96       	adiw	r24, 0x01	; 1
 13e:	84 31       	cpi	r24, 0x14	; 20
 140:	91 05       	cpc	r25, r1
 142:	99 f7       	brne	.-26     	; 0x12a <__vector_13+0x38>
    {
        aRunningAverageBuffer[uiLoop-1] = aRunningAverageBuffer[uiLoop];
    };

    // current sample on last index
    aRunningAverageBuffer[(MAX_ADC_HIST-1)] = ucCurrentSample;
 144:	89 81       	ldd	r24, Y+1	; 0x01
 146:	80 93 78 00 	sts	0x0078, r24
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	20 e0       	ldi	r18, 0x00	; 0
 150:	30 e0       	ldi	r19, 0x00	; 0
    uiSumm = 0;
    
    // add up all data
    for(uiLoop=0;uiLoop<MAX_ADC_HIST; uiLoop++)
    {
        uiSumm = uiSumm + aRunningAverageBuffer[uiLoop];
 152:	65 e6       	ldi	r22, 0x65	; 101
 154:	70 e0       	ldi	r23, 0x00	; 0
 156:	fb 01       	movw	r30, r22
 158:	e2 0f       	add	r30, r18
 15a:	f3 1f       	adc	r31, r19
 15c:	40 81       	ld	r20, Z
 15e:	84 0f       	add	r24, r20
 160:	91 1d       	adc	r25, r1
    aRunningAverageBuffer[(MAX_ADC_HIST-1)] = ucCurrentSample;

    uiSumm = 0;
    
    // add up all data
    for(uiLoop=0;uiLoop<MAX_ADC_HIST; uiLoop++)
 162:	2f 5f       	subi	r18, 0xFF	; 255
 164:	3f 4f       	sbci	r19, 0xFF	; 255
 166:	24 31       	cpi	r18, 0x14	; 20
 168:	31 05       	cpc	r19, r1
 16a:	a9 f7       	brne	.-22     	; 0x156 <__vector_13+0x64>
    {
        uiSumm = uiSumm + aRunningAverageBuffer[uiLoop];
    };

    // update average
    ucADCMeanValue = (unsigned char)(uiSumm / MAX_ADC_HIST);
 16c:	64 e1       	ldi	r22, 0x14	; 20
 16e:	70 e0       	ldi	r23, 0x00	; 0
 170:	8c d1       	rcall	.+792    	; 0x48a <__udivmodhi4>
 172:	60 93 7f 00 	sts	0x007F, r22
    OCR0B = ucADCMeanValue;
 176:	80 91 7f 00 	lds	r24, 0x007F
 17a:	8c bf       	out	0x3c, r24	; 60
        
}
 17c:	0f 90       	pop	r0
 17e:	cf 91       	pop	r28
 180:	df 91       	pop	r29
 182:	ff 91       	pop	r31
 184:	ef 91       	pop	r30
 186:	bf 91       	pop	r27
 188:	af 91       	pop	r26
 18a:	9f 91       	pop	r25
 18c:	8f 91       	pop	r24
 18e:	7f 91       	pop	r23
 190:	6f 91       	pop	r22
 192:	5f 91       	pop	r21
 194:	4f 91       	pop	r20
 196:	3f 91       	pop	r19
 198:	2f 91       	pop	r18
 19a:	0f 90       	pop	r0
 19c:	0f be       	out	0x3f, r0	; 63
 19e:	0f 90       	pop	r0
 1a0:	1f 90       	pop	r1
 1a2:	18 95       	reti

000001a4 <DebounceKeys>:


// Keyboard debouncing 
void DebounceKeys(void)
{
 1a4:	df 93       	push	r29
 1a6:	cf 93       	push	r28
 1a8:	0f 92       	push	r0
 1aa:	cd b7       	in	r28, 0x3d	; 61
 1ac:	de b7       	in	r29, 0x3e	; 62
	unsigned int uiLoop;
    volatile unsigned char  ucTempState;		// needed for array checking

	ucOldDebouncedState = ucDebouncedState;		// save old value to check if something has changed
 1ae:	80 91 7a 00 	lds	r24, 0x007A
 1b2:	80 93 79 00 	sts	0x0079, r24

    // read hardware here
	aKeyState[ucDebounceIndex] = (~(PINA & _BV(BIT_EN_INP))) & _BV(BIT_EN_INP);// we only process a single key (low active), mask rest
 1b6:	90 91 7c 00 	lds	r25, 0x007C
 1ba:	89 b3       	in	r24, 0x19	; 25
 1bc:	82 70       	andi	r24, 0x02	; 2
 1be:	80 95       	com	r24
 1c0:	82 70       	andi	r24, 0x02	; 2
 1c2:	e9 e8       	ldi	r30, 0x89	; 137
 1c4:	f0 e0       	ldi	r31, 0x00	; 0
 1c6:	e9 0f       	add	r30, r25
 1c8:	f1 1d       	adc	r31, r1
 1ca:	80 83       	st	Z, r24
	++ucDebounceIndex;
 1cc:	80 91 7c 00 	lds	r24, 0x007C
 1d0:	8f 5f       	subi	r24, 0xFF	; 255
 1d2:	80 93 7c 00 	sts	0x007C, r24

	ucTempState = 0xFF;
 1d6:	8f ef       	ldi	r24, 0xFF	; 255
 1d8:	89 83       	std	Y+1, r24	; 0x01
 1da:	80 e0       	ldi	r24, 0x00	; 0
 1dc:	90 e0       	ldi	r25, 0x00	; 0

    // iterate through the last states and see if each
    // bit of each state is 1
	for(uiLoop=0; uiLoop < (MAX_KEY_CHECKS-1); uiLoop++)
		ucTempState = ucTempState & aKeyState[uiLoop];
 1de:	49 e8       	ldi	r20, 0x89	; 137
 1e0:	50 e0       	ldi	r21, 0x00	; 0
 1e2:	fa 01       	movw	r30, r20
 1e4:	e8 0f       	add	r30, r24
 1e6:	f9 1f       	adc	r31, r25
 1e8:	30 81       	ld	r19, Z
 1ea:	29 81       	ldd	r18, Y+1	; 0x01
 1ec:	23 23       	and	r18, r19
 1ee:	29 83       	std	Y+1, r18	; 0x01

	ucTempState = 0xFF;

    // iterate through the last states and see if each
    // bit of each state is 1
	for(uiLoop=0; uiLoop < (MAX_KEY_CHECKS-1); uiLoop++)
 1f0:	01 96       	adiw	r24, 0x01	; 1
 1f2:	84 30       	cpi	r24, 0x04	; 4
 1f4:	91 05       	cpc	r25, r1
 1f6:	a9 f7       	brne	.-22     	; 0x1e2 <DebounceKeys+0x3e>
		ucTempState = ucTempState & aKeyState[uiLoop];

	ucDebouncedState = ucTempState;
 1f8:	89 81       	ldd	r24, Y+1	; 0x01
 1fa:	80 93 7a 00 	sts	0x007A, r24

    // wrap around pointer 
	if(ucDebounceIndex >= MAX_KEY_CHECKS)
 1fe:	80 91 7c 00 	lds	r24, 0x007C
 202:	85 30       	cpi	r24, 0x05	; 5
 204:	10 f0       	brcs	.+4      	; 0x20a <DebounceKeys+0x66>
		ucDebounceIndex=0;
 206:	10 92 7c 00 	sts	0x007C, r1

    // check if external enable input changed
    if((ucOldDebouncedState & _BV(BIT_EN_INP)) != (ucDebouncedState & _BV(BIT_EN_INP)))
 20a:	80 91 79 00 	lds	r24, 0x0079
 20e:	20 91 7a 00 	lds	r18, 0x007A
 212:	30 e0       	ldi	r19, 0x00	; 0
 214:	90 e0       	ldi	r25, 0x00	; 0
 216:	82 27       	eor	r24, r18
 218:	93 27       	eor	r25, r19
 21a:	81 ff       	sbrs	r24, 1
 21c:	02 c0       	rjmp	.+4      	; 0x222 <DebounceKeys+0x7e>
    {
        // check if it was a low to high transition
        if(ucDebouncedState & _BV(BIT_EN_INP))
 21e:	80 91 7a 00 	lds	r24, 0x007A
        {
//            PORT_LED_EXSTAT = PORT_LED_EXSTAT ^ _BV(BIT_LED_EXSTAT);  // ext. stat off            
        };
    };
}
 222:	0f 90       	pop	r0
 224:	cf 91       	pop	r28
 226:	df 91       	pop	r29
 228:	08 95       	ret

0000022a <__vector_6>:
// ================================================================ 
// time management handler, called every 1ms via CTC mode interrupt
// ================================================================ 

ISR(TIM1_COMPA_vect)
{
 22a:	1f 92       	push	r1
 22c:	0f 92       	push	r0
 22e:	0f b6       	in	r0, 0x3f	; 63
 230:	0f 92       	push	r0
 232:	11 24       	eor	r1, r1
 234:	2f 93       	push	r18
 236:	3f 93       	push	r19
 238:	4f 93       	push	r20
 23a:	5f 93       	push	r21
 23c:	6f 93       	push	r22
 23e:	7f 93       	push	r23
 240:	8f 93       	push	r24
 242:	9f 93       	push	r25
 244:	af 93       	push	r26
 246:	bf 93       	push	r27
 248:	ef 93       	push	r30
 24a:	ff 93       	push	r31
    static unsigned int uiMorseDelay = MORSE_SYNC_PAUSE;
    static unsigned char ucCode = 0;

    // read in error pins from SWM controller
    // we need only the lower 3 bits
    ucErrorCode = PINB & 0x07; 
 24c:	86 b3       	in	r24, 0x16	; 22
 24e:	87 70       	andi	r24, 0x07	; 7
 250:	80 93 8e 00 	sts	0x008E, r24
        
    // ==== CPU LED blink code below ====
    if(!(uiBlinkDelay--))
 254:	80 91 62 00 	lds	r24, 0x0062
 258:	90 91 63 00 	lds	r25, 0x0063
 25c:	9c 01       	movw	r18, r24
 25e:	21 50       	subi	r18, 0x01	; 1
 260:	30 40       	sbci	r19, 0x00	; 0
 262:	30 93 63 00 	sts	0x0063, r19
 266:	20 93 62 00 	sts	0x0062, r18
 26a:	00 97       	sbiw	r24, 0x00	; 0
 26c:	51 f4       	brne	.+20     	; 0x282 <__stack+0x23>
    {
        PORT_LED_CPU = PIN_LED_CPU ^ _BV(BIT_LED_CPU);
 26e:	99 b3       	in	r25, 0x19	; 25
 270:	80 e1       	ldi	r24, 0x10	; 16
 272:	89 27       	eor	r24, r25
 274:	8b bb       	out	0x1b, r24	; 27
        uiBlinkDelay = 500;
 276:	84 ef       	ldi	r24, 0xF4	; 244
 278:	91 e0       	ldi	r25, 0x01	; 1
 27a:	90 93 63 00 	sts	0x0063, r25
 27e:	80 93 62 00 	sts	0x0062, r24
    // ==========================
    // ==== morse code below ====
    // ==========================

    // LED long off to "sync user"
    if(eMorseState == eMorsePause)
 282:	80 91 7d 00 	lds	r24, 0x007D
 286:	88 23       	and	r24, r24
 288:	61 f5       	brne	.+88     	; 0x2e2 <__stack+0x83>
    {
        PORT_LED_STAT = PORT_LED_STAT | _BV(BIT_LED_STAT);          // switch off LED (active low)
 28a:	eb e3       	ldi	r30, 0x3B	; 59
 28c:	f0 e0       	ldi	r31, 0x00	; 0
 28e:	90 81       	ld	r25, Z
 290:	90 62       	ori	r25, 0x20	; 32
 292:	90 83       	st	Z, r25
        PORT_LED_EXSTAT = PORT_LED_EXSTAT & ~(_BV(BIT_LED_EXSTAT)); // ext. stat off 
 294:	90 81       	ld	r25, Z
 296:	97 7f       	andi	r25, 0xF7	; 247
 298:	90 83       	st	Z, r25

        // check if delay has expired
        if(!(uiMorseDelay--))
 29a:	20 91 60 00 	lds	r18, 0x0060
 29e:	30 91 61 00 	lds	r19, 0x0061
 2a2:	a9 01       	movw	r20, r18
 2a4:	41 50       	subi	r20, 0x01	; 1
 2a6:	50 40       	sbci	r21, 0x00	; 0
 2a8:	50 93 61 00 	sts	0x0061, r21
 2ac:	40 93 60 00 	sts	0x0060, r20
 2b0:	21 15       	cp	r18, r1
 2b2:	31 05       	cpc	r19, r1
 2b4:	b1 f4       	brne	.+44     	; 0x2e2 <__stack+0x83>
        {
            uiMorseDelay = MORSE_LONG_BIT;
 2b6:	8c e2       	ldi	r24, 0x2C	; 44
 2b8:	91 e0       	ldi	r25, 0x01	; 1
 2ba:	90 93 61 00 	sts	0x0061, r25
 2be:	80 93 60 00 	sts	0x0060, r24
            eMorseState = eMorseStart;
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	80 93 7d 00 	sts	0x007D, r24

    // start bit (longer than the morse code)
    if(eMorseState == eMorseStart)
    {
        // switch on LEDs
        PORT_LED_STAT = PORT_LED_STAT & ~(_BV(BIT_LED_STAT));   // switch on LED (active low)
 2c8:	80 81       	ld	r24, Z
 2ca:	8f 7d       	andi	r24, 0xDF	; 223
 2cc:	80 83       	st	Z, r24
        PORT_LED_EXSTAT = PORT_LED_EXSTAT | _BV(BIT_LED_EXSTAT);// ext. stat on 
 2ce:	80 81       	ld	r24, Z
 2d0:	88 60       	ori	r24, 0x08	; 8
 2d2:	80 83       	st	Z, r24

        // check if delay has expired
        if(!(uiMorseDelay--))
 2d4:	8b e2       	ldi	r24, 0x2B	; 43
 2d6:	91 e0       	ldi	r25, 0x01	; 1
 2d8:	90 93 61 00 	sts	0x0061, r25
 2dc:	80 93 60 00 	sts	0x0060, r24
 2e0:	31 c0       	rjmp	.+98     	; 0x344 <__stack+0xe5>
            eMorseState = eMorseStart;
        };
    };

    // start bit (longer than the morse code)
    if(eMorseState == eMorseStart)
 2e2:	81 30       	cpi	r24, 0x01	; 1
 2e4:	79 f5       	brne	.+94     	; 0x344 <__stack+0xe5>
    {
        // switch on LEDs
        PORT_LED_STAT = PORT_LED_STAT & ~(_BV(BIT_LED_STAT));   // switch on LED (active low)
 2e6:	eb e3       	ldi	r30, 0x3B	; 59
 2e8:	f0 e0       	ldi	r31, 0x00	; 0
 2ea:	80 81       	ld	r24, Z
 2ec:	8f 7d       	andi	r24, 0xDF	; 223
 2ee:	80 83       	st	Z, r24
        PORT_LED_EXSTAT = PORT_LED_EXSTAT | _BV(BIT_LED_EXSTAT);// ext. stat on 
 2f0:	80 81       	ld	r24, Z
 2f2:	88 60       	ori	r24, 0x08	; 8
 2f4:	80 83       	st	Z, r24

        // check if delay has expired
        if(!(uiMorseDelay--))
 2f6:	80 91 60 00 	lds	r24, 0x0060
 2fa:	90 91 61 00 	lds	r25, 0x0061
 2fe:	9c 01       	movw	r18, r24
 300:	21 50       	subi	r18, 0x01	; 1
 302:	30 40       	sbci	r19, 0x00	; 0
 304:	30 93 61 00 	sts	0x0061, r19
 308:	20 93 60 00 	sts	0x0060, r18
 30c:	00 97       	sbiw	r24, 0x00	; 0
 30e:	d1 f4       	brne	.+52     	; 0x344 <__stack+0xe5>
        {
            uiMorseDelay = MORSE_SYNC_PAUSE;// load delay counter
 310:	88 ee       	ldi	r24, 0xE8	; 232
 312:	93 e0       	ldi	r25, 0x03	; 3
 314:	90 93 61 00 	sts	0x0061, r25
 318:	80 93 60 00 	sts	0x0060, r24
            eMorseState = eMorseDelay;      // next state
 31c:	82 e0       	ldi	r24, 0x02	; 2
 31e:	80 93 7d 00 	sts	0x007D, r24
            ucCode = ucErrorCode;           // prepare static error counter for countdown
 322:	80 91 8e 00 	lds	r24, 0x008E
 326:	80 93 64 00 	sts	0x0064, r24
    };

    if(eMorseState == eMorseDelay)
    {
        // LEDs off
        PORT_LED_STAT = PORT_LED_STAT | _BV(BIT_LED_STAT);          // switch off LED (active low)
 32a:	80 81       	ld	r24, Z
 32c:	80 62       	ori	r24, 0x20	; 32
 32e:	80 83       	st	Z, r24
        PORT_LED_EXSTAT = PORT_LED_EXSTAT & ~(_BV(BIT_LED_EXSTAT)); // ext. stat off 
 330:	80 81       	ld	r24, Z
 332:	87 7f       	andi	r24, 0xF7	; 247
 334:	80 83       	st	Z, r24

        // check if delay has expired
        if(!(uiMorseDelay--))
 336:	87 ee       	ldi	r24, 0xE7	; 231
 338:	93 e0       	ldi	r25, 0x03	; 3
 33a:	90 93 61 00 	sts	0x0061, r25
 33e:	80 93 60 00 	sts	0x0060, r24
 342:	28 c0       	rjmp	.+80     	; 0x394 <__stack+0x135>
            eMorseState = eMorseDelay;      // next state
            ucCode = ucErrorCode;           // prepare static error counter for countdown
        };
    };

    if(eMorseState == eMorseDelay)
 344:	80 91 7d 00 	lds	r24, 0x007D
 348:	82 30       	cpi	r24, 0x02	; 2
 34a:	21 f5       	brne	.+72     	; 0x394 <__stack+0x135>
    {
        // LEDs off
        PORT_LED_STAT = PORT_LED_STAT | _BV(BIT_LED_STAT);          // switch off LED (active low)
 34c:	eb e3       	ldi	r30, 0x3B	; 59
 34e:	f0 e0       	ldi	r31, 0x00	; 0
 350:	80 81       	ld	r24, Z
 352:	80 62       	ori	r24, 0x20	; 32
 354:	80 83       	st	Z, r24
        PORT_LED_EXSTAT = PORT_LED_EXSTAT & ~(_BV(BIT_LED_EXSTAT)); // ext. stat off 
 356:	80 81       	ld	r24, Z
 358:	87 7f       	andi	r24, 0xF7	; 247
 35a:	80 83       	st	Z, r24

        // check if delay has expired
        if(!(uiMorseDelay--))
 35c:	80 91 60 00 	lds	r24, 0x0060
 360:	90 91 61 00 	lds	r25, 0x0061
 364:	9c 01       	movw	r18, r24
 366:	21 50       	subi	r18, 0x01	; 1
 368:	30 40       	sbci	r19, 0x00	; 0
 36a:	30 93 61 00 	sts	0x0061, r19
 36e:	20 93 60 00 	sts	0x0060, r18
 372:	00 97       	sbiw	r24, 0x00	; 0
 374:	79 f4       	brne	.+30     	; 0x394 <__stack+0x135>
        {
            uiMorseDelay = MORSE_SHORT_BIT;     // load delay counter
 376:	84 e6       	ldi	r24, 0x64	; 100
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	90 93 61 00 	sts	0x0061, r25
 37e:	80 93 60 00 	sts	0x0060, r24
            eMorseState = eMorseCodeOutputOn;   // next state
 382:	83 e0       	ldi	r24, 0x03	; 3
 384:	80 93 7d 00 	sts	0x007D, r24
            ucCode = ucErrorCode;               // prepare static error counter for countdown
 388:	80 91 8e 00 	lds	r24, 0x008E
 38c:	80 93 64 00 	sts	0x0064, r24
 390:	83 e0       	ldi	r24, 0x03	; 3
 392:	07 c0       	rjmp	.+14     	; 0x3a2 <__stack+0x143>
        };
    };

    if((eMorseState == eMorseCodeOutputOn) || (eMorseState == eMorseCodeOutputOff))
 394:	80 91 7d 00 	lds	r24, 0x007D
 398:	98 2f       	mov	r25, r24
 39a:	93 50       	subi	r25, 0x03	; 3
 39c:	92 30       	cpi	r25, 0x02	; 2
 39e:	08 f0       	brcs	.+2      	; 0x3a2 <__stack+0x143>
 3a0:	62 c0       	rjmp	.+196    	; 0x466 <__stack+0x207>
    {
        // check if error code is != 0
        if(ucCode)
 3a2:	90 91 64 00 	lds	r25, 0x0064
 3a6:	99 23       	and	r25, r25
 3a8:	09 f4       	brne	.+2      	; 0x3ac <__stack+0x14d>
 3aa:	55 c0       	rjmp	.+170    	; 0x456 <__stack+0x1f7>
        {
            // check if we are in the "ON" Phase of morse
            if(eMorseState == eMorseCodeOutputOn)
 3ac:	83 30       	cpi	r24, 0x03	; 3
 3ae:	61 f5       	brne	.+88     	; 0x408 <__stack+0x1a9>
            {
                // switch on LEDs
                PORT_LED_STAT = PORT_LED_STAT & ~(_BV(BIT_LED_STAT));   // switch on LED (active low)
 3b0:	eb e3       	ldi	r30, 0x3B	; 59
 3b2:	f0 e0       	ldi	r31, 0x00	; 0
 3b4:	80 81       	ld	r24, Z
 3b6:	8f 7d       	andi	r24, 0xDF	; 223
 3b8:	80 83       	st	Z, r24
                PORT_LED_EXSTAT = PORT_LED_EXSTAT | _BV(BIT_LED_EXSTAT);// ext. stat on 
 3ba:	80 81       	ld	r24, Z
 3bc:	88 60       	ori	r24, 0x08	; 8
 3be:	80 83       	st	Z, r24
        
                // check if delay has expired
                if(!(uiMorseDelay--))
 3c0:	20 91 60 00 	lds	r18, 0x0060
 3c4:	30 91 61 00 	lds	r19, 0x0061
 3c8:	a9 01       	movw	r20, r18
 3ca:	41 50       	subi	r20, 0x01	; 1
 3cc:	50 40       	sbci	r21, 0x00	; 0
 3ce:	50 93 61 00 	sts	0x0061, r21
 3d2:	40 93 60 00 	sts	0x0060, r20
 3d6:	21 15       	cp	r18, r1
 3d8:	31 05       	cpc	r19, r1
 3da:	b1 f4       	brne	.+44     	; 0x408 <__stack+0x1a9>
                {
                    uiMorseDelay = MORSE_BIT_PAUSE;
 3dc:	84 ef       	ldi	r24, 0xF4	; 244
 3de:	91 e0       	ldi	r25, 0x01	; 1
 3e0:	90 93 61 00 	sts	0x0061, r25
 3e4:	80 93 60 00 	sts	0x0060, r24
                    eMorseState = eMorseCodeOutputOff;
 3e8:	84 e0       	ldi	r24, 0x04	; 4
 3ea:	80 93 7d 00 	sts	0x007D, r24
            
            // check if we are in the "OFF" phase of morse
            if(eMorseState == eMorseCodeOutputOff)
            {
                // switch off LEDs
                PORT_LED_STAT = PORT_LED_STAT | _BV(BIT_LED_STAT);          // switch off LED (active low)
 3ee:	80 81       	ld	r24, Z
 3f0:	80 62       	ori	r24, 0x20	; 32
 3f2:	80 83       	st	Z, r24
                PORT_LED_EXSTAT = PORT_LED_EXSTAT & ~(_BV(BIT_LED_EXSTAT)); // ext. stat off 
 3f4:	80 81       	ld	r24, Z
 3f6:	87 7f       	andi	r24, 0xF7	; 247
 3f8:	80 83       	st	Z, r24
        
                // check if delay has expired
                if(!(uiMorseDelay--))
 3fa:	83 ef       	ldi	r24, 0xF3	; 243
 3fc:	91 e0       	ldi	r25, 0x01	; 1
 3fe:	90 93 61 00 	sts	0x0061, r25
 402:	80 93 60 00 	sts	0x0060, r24
 406:	2f c0       	rjmp	.+94     	; 0x466 <__stack+0x207>
                    eMorseState = eMorseCodeOutputOff;
                };
            };
            
            // check if we are in the "OFF" phase of morse
            if(eMorseState == eMorseCodeOutputOff)
 408:	80 91 7d 00 	lds	r24, 0x007D
 40c:	84 30       	cpi	r24, 0x04	; 4
 40e:	59 f5       	brne	.+86     	; 0x466 <__stack+0x207>
            {
                // switch off LEDs
                PORT_LED_STAT = PORT_LED_STAT | _BV(BIT_LED_STAT);          // switch off LED (active low)
 410:	eb e3       	ldi	r30, 0x3B	; 59
 412:	f0 e0       	ldi	r31, 0x00	; 0
 414:	80 81       	ld	r24, Z
 416:	80 62       	ori	r24, 0x20	; 32
 418:	80 83       	st	Z, r24
                PORT_LED_EXSTAT = PORT_LED_EXSTAT & ~(_BV(BIT_LED_EXSTAT)); // ext. stat off 
 41a:	80 81       	ld	r24, Z
 41c:	87 7f       	andi	r24, 0xF7	; 247
 41e:	80 83       	st	Z, r24
        
                // check if delay has expired
                if(!(uiMorseDelay--))
 420:	20 91 60 00 	lds	r18, 0x0060
 424:	30 91 61 00 	lds	r19, 0x0061
 428:	a9 01       	movw	r20, r18
 42a:	41 50       	subi	r20, 0x01	; 1
 42c:	50 40       	sbci	r21, 0x00	; 0
 42e:	50 93 61 00 	sts	0x0061, r21
 432:	40 93 60 00 	sts	0x0060, r20
 436:	21 15       	cp	r18, r1
 438:	31 05       	cpc	r19, r1
 43a:	a9 f4       	brne	.+42     	; 0x466 <__stack+0x207>
                {
                    uiMorseDelay = MORSE_SHORT_BIT;
 43c:	24 e6       	ldi	r18, 0x64	; 100
 43e:	30 e0       	ldi	r19, 0x00	; 0
 440:	30 93 61 00 	sts	0x0061, r19
 444:	20 93 60 00 	sts	0x0060, r18
                    eMorseState = eMorseCodeOutputOn;
 448:	83 e0       	ldi	r24, 0x03	; 3
 44a:	80 93 7d 00 	sts	0x007D, r24
                    ucCode--;
 44e:	91 50       	subi	r25, 0x01	; 1
 450:	90 93 64 00 	sts	0x0064, r25
 454:	08 c0       	rjmp	.+16     	; 0x466 <__stack+0x207>
                };
            };
        }
        else
        {
                uiMorseDelay = MORSE_SYNC_PAUSE;
 456:	88 ee       	ldi	r24, 0xE8	; 232
 458:	93 e0       	ldi	r25, 0x03	; 3
 45a:	90 93 61 00 	sts	0x0061, r25
 45e:	80 93 60 00 	sts	0x0060, r24
                eMorseState = eMorsePause;
 462:	10 92 7d 00 	sts	0x007D, r1
        };
    };
    DebounceKeys();
 466:	9e de       	rcall	.-708    	; 0x1a4 <DebounceKeys>
}
 468:	ff 91       	pop	r31
 46a:	ef 91       	pop	r30
 46c:	bf 91       	pop	r27
 46e:	af 91       	pop	r26
 470:	9f 91       	pop	r25
 472:	8f 91       	pop	r24
 474:	7f 91       	pop	r23
 476:	6f 91       	pop	r22
 478:	5f 91       	pop	r21
 47a:	4f 91       	pop	r20
 47c:	3f 91       	pop	r19
 47e:	2f 91       	pop	r18
 480:	0f 90       	pop	r0
 482:	0f be       	out	0x3f, r0	; 63
 484:	0f 90       	pop	r0
 486:	1f 90       	pop	r1
 488:	18 95       	reti

0000048a <__udivmodhi4>:
 48a:	aa 1b       	sub	r26, r26
 48c:	bb 1b       	sub	r27, r27
 48e:	51 e1       	ldi	r21, 0x11	; 17
 490:	07 c0       	rjmp	.+14     	; 0x4a0 <__udivmodhi4_ep>

00000492 <__udivmodhi4_loop>:
 492:	aa 1f       	adc	r26, r26
 494:	bb 1f       	adc	r27, r27
 496:	a6 17       	cp	r26, r22
 498:	b7 07       	cpc	r27, r23
 49a:	10 f0       	brcs	.+4      	; 0x4a0 <__udivmodhi4_ep>
 49c:	a6 1b       	sub	r26, r22
 49e:	b7 0b       	sbc	r27, r23

000004a0 <__udivmodhi4_ep>:
 4a0:	88 1f       	adc	r24, r24
 4a2:	99 1f       	adc	r25, r25
 4a4:	5a 95       	dec	r21
 4a6:	a9 f7       	brne	.-22     	; 0x492 <__udivmodhi4_loop>
 4a8:	80 95       	com	r24
 4aa:	90 95       	com	r25
 4ac:	bc 01       	movw	r22, r24
 4ae:	cd 01       	movw	r24, r26
 4b0:	08 95       	ret

000004b2 <_exit>:
 4b2:	f8 94       	cli

000004b4 <__stop_program>:
 4b4:	ff cf       	rjmp	.-2      	; 0x4b4 <__stop_program>
